
# Replication code for Foley, M., Smead, R., Forber, P., Riedl, C. (2021). “Avoiding the Bullies: Resilience of Cooperation among Unequals,” in press, PLOS Computational Biology.


We provide two sets of simulation code: One for the model in ranks are static and one for the model in which ranks themselves are dynamic. Both models can be complied and executed in the same way, so we provide one set of instructions below. In both models, network learning can be turned on or off using command line parameters. 

There are three parts to the replication:

1. A python script that generates configuration files so that many simulations spanning different parameters can be run in batches
2. Code that executes one simulation using input from a configuration file. This can be executed in a distributed fashion on a cluster computer.
3. Code to help analyze the output generated by the simulation code.

## Compiling the Code

To compile simulation code with `g++`:

```bash
g++ -g -O3 -Wall -fopenmp  SimCode/*.cpp -I /usr/local/opt/boost/include -L /usr/local/opt/boost/lib -std=c++11 -o ExecutableFileName
```

The `-fopenmp` flag is for running multiple simulations in parallel, not necessary.  Further, -I and -L are flags for the include and library folders of the Boost library, and those paths may differ on your machine.  Boost is required to run the code.


## Running Simulations

Once you have an executable (let's call it "Bullies" for example), you'll need to set up some simulations to run.  Running the driver.py script in python will do this.  You can edit the driver.py file to change the parameters of the simulations.

Parameters are as follows:  

- `num_seeds`: the number of random seeds.
- `pop_list_in`: list of populations.
- `net_discount_list_in`: list of network discount rates. (keep this the same as strategy discounts in general)
- `net_tremble_list_in`: list of network tremble rates (keep the same values for strategy tremble rates)
- `net_speed_list_in`: list of network learning speeds
- `strat_speed_list_in`: list of strategy learning speeds
- `net_sym_list_in`: boolean value - is network learning symmetric?  When I add weight to someone I'm visiting, do they add their payoff to their outgoing network link to me?
- `strat_sym_list_in`: boolean - is strategy learning symmetric?  Are my host and visiting strategies equal?
- `t_max`: How many time steps to run out simulation
- `dh`: Dove-Hawk payoff, this is the first command line argument of driver
- `dd`: Dove-dove payoff, second command line argument.  HH is set to 0, HD is set to 1.
- `f_list`: list of F payoff values, which goes to the winner of a ranked HH interaction.

Set values that you would like to run, and run the driver script (make sure to include 2 arguments for the dh and dd payoffs).

This will create an input folder, something like 

```bash
"HDInnov_Pop-20_Discount-0.01_Tremble-0.01_NLS-0_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.3-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0"
```

To run the parameters you just created,

```bash
./Bullies Pop-20_Discount-0.01_Tremble-0.01_NLS-0_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.3-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0 INPUTFILENUMBER THREADS SEEDS STARTKEY STARTSEED 7
```

`INPUTFILENUMBER` refers to the number at the end of each configuration file.  0 will always be the first, but there may be more configuration files.

`THREADS` is the number of parallel threads to run.  On most local machines, 8 or 16 is likely the number of threads available, which should not be exceeded or the run will be inefficient.  On clusters, you can run many more simulations at one time.

`SEEDS` is the number of random seeds to run.

`STARTKEY` is the index of the first key to run (generally just keep this at 0 unless you want to run a specific key)

`STARTSEED` is the index of the first seed to run (generally keep at 0)


## Running Simulations from the Paper

We have already created all the necessary input folders and files to run all simulations for the results in the main paper.  

Below is a mapping from the input folders to the figures that they correspond to:

STATIC RANK INPUTS

Figure 2b: Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-0_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0

Figure 3a: Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0

Figure 3b: Input_HDInnov_Pop-20-50-100-200-500_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0

Figure 3c: Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.6

Figure 3d: Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0

Figure 3e: Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0


## Additional Parameters for Dynamic Rank Model

Figure 5a: Input_HDInnov_Pop-20_Discount-N-0.01_S-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.4

Figure 5b: Input_HDInnov_Pop-20_Discount-N-0.01_S-0.01_Tremble-0.01_NLS-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.0-0.1-0.2-0.3-0.4-0.5-0.6-0.7-0.8-0.9-1.0

## Combined Inputs


Figure 5c: DYNAMIC RANK Input_HDInnov_Pop-20_Discount-N-0.01_S-0.01_Tremble-0.01_NLS-0-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.6
+ STATIC RANK Input_HDInnov_Pop-20_Discount-ND-0.01_SD-0.01_Tremble-0.01_NLS-0-1_SLS-1_SymN-0_SymS-0_CopyProb-0_CopyError-0_ExpProb-0_InnovNoise-0_CoupleFn-Fight_P-0.0-1.0-0.4-0.6_Bon-0.6

Figure 5d uses same data as Figure 5c


## Simulation Output Data

There are multiple simulation output files that contain all the data necessary to replicate the results.  The list of files and a short description can be seen below.

Weights files contain the adjacency matrices over time (specific times can be specified in code).  Each matrix is flattened into a line for output purposes, but can be reshaped into an NxN to retrieve the adjacency matrix.

EvoStats contain the distribution of interaction types over time.  This is the expected proportion of any given interaction type in a time step (see paper for details on calculation). In a 2x2 game such as Hawk Dove, there are 4 possible interaction types.  Hawk Hawk is the first column, Hawk Dove is the second column, Dove Hawk is the third column, Dove Dove is the last column.  There is an index column you can ignore, which will correspond to the timesteps you choose to save.

StrategyVisit files contain visiting strategy profiles of agents over time.  The indexing is such that the first 2 columns belong to Agent 0, second 2 columns belong to Agent 1, and so on.  For each agent, the first column is their normalized weight towards playing hawk, and the second is just 1 minus this value, as the normalized weight to play dove.

StrategyHost files contain the same information as StrategyVisit, but with host strategy profiles instead of visiting strategy.

Scores files contain the scores which determine fitness ranking.  Scores usually start random, and only change if you are running the dynamic rank model.

NetSTD tracks the total incoming weight for one agent over the entire simulation.  So this gives us the expected number of incoming interactions at any given time step.  This is the same agent tracked in OutFS.

OutFS tracks the visiting and host strategy (proportion of playing hawk) for one agent over the entire simulation.  The first column is visitor hawk proportion, second column is host hawk proportion. The same agent is tracked as in NetSTD.

OutScore contains the ranks of each agent.  It is structured such that the first N values (N being population size) are the ranks of each agent in the first time step, the next N values are the ranks in the next time step, and so son.

TotalPayoff is the total cumulative payoff of each agent over the entire simulation. 

TotalInteractions tracks the actual interactions that take place.  Is is structured as follows:  Each row represents one time step (90 total time steps tracked, see Network.h times_tracked to see or modify these times).  Then the first 4 values in each row are the first agents interactions.  The interactions are structured exactly as they are in EvoStats (Hawk Hawk is first column, followed by Hawk Dove, Dove Hawk and finally Dove Dove).  So the 5th value in the row is the second agents total Hawk Hawk interactions.  These are tracked cumulatively.

